#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# ------------------------------------------------------------------------------
# 
# MIT License
# 
# Copyright (c) 2017 Gabriele Girelli
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# 
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# 
# Author: Gabriele Girelli
# Email: gigi.ga90@gmail.com
# Project: GPSeq
# Description: estimate region centrality from GPSeq sequencing data.
# 
# Changelog:
#   v2.0.0 - first release as a python package.
# 
# ------------------------------------------------------------------------------



# DEPENDENCIES =================================================================

import argparse
import os
import pybedtools as pbt
import sys

# PARAMETERS ===================================================================

# Add script description
parser = argparse.ArgumentParser(description = """
Description:

 Estimate global centrality. The script performs the following steps:
  (1) Identify & sort chromosomes
  (2) Generate bins
  (3) Group cutsites (intersect)
  (4) Normalize over last condition.
  (5) Prepare domain
  (6) Assign reads to bins (intersect)
  (7) Calculate bin statistics
  (8) Combine condition into a single table
  (9) Estimate centrality
  (10) Rank bins
  (11) Write output

Notes:

 # Cutsite domain --------------------------------------------------------------

  The cutsite domain can be specified as follows:
  1 - all genomic cutsites (universe)
  2 - all cutsites restricted in the experiment (union)
  3 - all cutsites restricted in a condition (separate)
  4 - all cutsites restricted in all conditions (intersection)
  Default is 3 (separate). Also, note that if option 1 is selected, an
  additional argument -l is required.
  
  Statistics (mean, variance) metrics take into account only the cutsites
  included in the specified cutsite domain. The same cutsite domain is used for
  all estimates.
  
  Options 3 and 4 include an empty-cutsites/grups removal step. In this case,
  they are removed before bin assignment, while empty bins are kept. Also,
  normalization is performed after empty bin removal but before bin assignment,
  i.e., either on the grouped or single cutsites.
 
 # Resolution ------------------------------------------------------------------

  Depending on the sequencing resolution, it might not be feasible to go for
  single-cutsite resolution. Thus, cutsite can be grouped for the statistics
  calculation using the -g option.
  
  In case of sub-chromosome bins, the ranking is done in an ordered
  chromosome-wise manner.
 
 # Select specific metrics -----------------------------------------------------

  By default, all the available metrics are calculated. Use -i to provide a list
  of the comma-separated metrics to calculate, while the rest would be excluded.
  Use the -e option to provide a list of the comma-separated metrics not to be
  calculated, while the rest would be included. The available metrics are:

 # -----------------------------------------------------------------------------
""", formatter_class = argparse.RawDescriptionHelpFormatter)

# Positional parameters
parser.add_argument('bedfile', type = str, nargs = '+',
	help = """At least two (2) GPSeq condition bedfiles, in increasing order of
restriction conditions intensity. Expected to be ordered per condition.""")

# Optional parameters
parser.add_argument('-o', '--output', type = str, nargs = 1,
	help = """Path to output folder.""", metavar = "outDir", required = True)
parser.add_argument('-c', '--cutsite-mode', type = int, nargs = 1,
	help = """Custite mode (see Notes).""", choices = range(1, 5),
	metavar = "csMode", default = 3)
csModeLabel = ["1:Universe", "2:Union", "3:Separate+Empty", "4:Intersection"]
parser.add_argument('-l', '--cutsite-bed', type = str, nargs = 1,
	help = """Path to cutsite bedfile. Required for -c1 when -g is not used.""",
	metavar = "csBed", default = None)
parser.add_argument('-b', '--bin-bed', type = str, nargs = 1,
	help = """Path to bin bedfile. If used, -s and -p are ignored.""",
	metavar = "binBed", default = None)
parser.add_argument('-s', '--bin-size', type = int, nargs = 1,
	help = """Bin size in bp. Default to chromosome-wide bins.""",
	metavar = "binSize", default = [0])
parser.add_argument('-p', '--bin-step', type = int, nargs = 1,
	help = """Bin step in bp. Default to bin binSize.""",
	metavar = "binStep", default = [0])
parser.add_argument('-g', '--group-size', type = int, nargs = 1,
	help = """Group size in bp. Used to group bins for statistics calculation.
	binSize must be divisible by groupSize. Not used by default.""",
	metavar = "groupSize", default = [0])
metrics = ['prob_2p', 'prob_f', 'prob_g', 'cor_2p', 'cor_f', 'cor_g', 'roc_2p',
	'roc_f', 'roc_g', 'var_2p', 'var_f', 'ff_2p', 'ff_f', 'cv_2p', 'cv_f']
parser.add_argument('-e', '--exclude', type = str, nargs = '*',
	help = """Space-separated list of metrics to exclude from calculation.
	All metrics BUT the specified ones are calculated.""",
	metavar = "metric", default = None, choices = metrics)
parser.add_argument('-i', '--include', type = str, nargs = '*',
	help = """Space-separated list of metrics to be calculated.
	Only the specified metrics are calculated.""",
	metavar = "metric", default = None, choices = metrics)
parser.add_argument('-r', '--prefix', type = str, nargs = 1,
	help = """Output name prefix.""", metavar = "prefix", default = [""])
parser.add_argument('-u', '--suffix', type = str, nargs = 1,
	help = """Output name suffix.""", metavar = "suffix", default = [""])

# Flag parameters
parser.add_argument('-y', '--do-all', action = 'store_const',
	help = """Do not ask for settings confirmation and proceed.""",
	const = True, default = False)
parser.add_argument('-d', '--debug-mode', action = 'store_const',
	help = """Debugging mode: save intermediate results.""",
	const = True, default = False)
parser.add_argument('-n', '--normalize', action = 'store_const',
	help = """Use last condition for normalization.""",
	const = True, default = False)

# Version flag
version = "2.0.0dev"
parser.add_argument('--version', action = 'version',
	version = '%s v%s' % (sys.argv[0], version,))

# Parse arguments
args = parser.parse_args()

# Check input ------------------------------------------------------------------

assert_msg = "at least two (2) GPSeq condition bedfiles,"
assert_msg += " in increasing order of restriction"
assert_msg += "intensity are required."
assert 2 <= len(args.bedfile), assert_msg

if args.normalize:
	assert_msg = "at least two (3) GPSeq condition bedfiles,"
	assert_msg += " in increasing order of restriction intensity are"
	assert_msg += " required when normalization is on (-n)."
	assert 3 <= len(args.bedfile), assert_msg

assert pbt.check_for_bedtools(), "bedtools required."

doExclude = not type(None)==type(args.exclude)
doInclude = not type(None)==type(args.include)
assert not(doExclude and doInclude), "options -e/-i cannot be used together."

for bp in args.bedfile:
	assert os.path.isfile(bp), "file not found: '%s'" % bp

assert_msg = ""
assertc = 1 == args.cutsite_mode and 0 == args.group_size[0]
assert not(assertc and type(None) == type(args.cutsite_list)), assert_msg

assert 0 <= args.bin_size[0], "bin size must be a positive integer."
assert 0 <= args.bin_step[0], "bin step must be a positive integer."
assert 0 <= args.group_size[0], "group size must be a positive integer."

assert_msg = "bin size must be greater then or equal to bin step."
assert args.bin_size[0] >= args.bin_step[0], assert_msg

if 0 != args.bin_step[0] and 0 == args.bin_size[0]:
	print("wARNING: missing bin size, ignoring -p option.")
	args.bin_step = [0]

if args.bin_size[0] != 0 and args.bin_step[0] == 0:
	args.bin_step = args.bin_size

if 0 != args.bin_size[0] and 0 != args.group_size[0]:
	assert_msg = "bin size must be divisible by group size."
	assert 0 == args.bin_size[0] % args.group_size[0], assert_msg

if 0 != args.bin_step[0] and 0 != args.group_size:
	assert_msg = "bin step must be greater than group size."
	assert args.bin_step[0] > args.group_size[0], assert_msg

# FUNCTION =====================================================================

def print_settings(args, clear = True):
	'''Show input settings, for confirmation.

	Args:
		args (Namespace): arguments parsed by argparse.
		clear (bool): clear screen before printing.
	'''
	s = " # GPSeq-centrality-estimate\n\n"

	if type(None) != type(args.bin_bed):
		s += " Bin be file: %s\n" % args.bin_bed[0]

	if 0 == args.bin_size[0] and type(None) == type(args.bin_bed):
		s += " Using chr-wide bins.\n"
	else:
		s += "   Bin size : %d\n   Bin step : %d\n" % (
			args.bin_size[0], args.bin_step[0])

	if 0 != args.group_size[0]:
		s += " Group size : %d\n" % args.group_size[0]

	s += "     Domain : %s\n" % csModeLabel[args.cutsite_mode - 1]

	if 1 == args.cutsite_mode:
		s += " Cutsite : %s\n" % args.cutsite_list[0]

	if 0 != len(args.prefix[0]): s += " Prefix : %s\n" % args.prefix[0]
	if 0 != len(args.suffix[0]): s += " Suffix : %s\n" % args.suffix[0]

	if args.normalize: s += " Normalizing over last condition.\n"
	if args.debug_mode: s += " Debugging mode ON.\n"

	doExclude = not type(None)==type(args.exclude)
	if doExclude: s += "\n Excluded metrics:\n  %s\n" % ", ".join(args.exclude)
	doInclude = not type(None)==type(args.include)
	if doInclude: s += "\n Included metrics:\n  %s\n" % ", ".join(args.include)

	s += "\n Output dir : %s\n  Bed files : \n" % args.output[0]
	s += "".join(["   %s\n" % bp for bp in args.bedfile])

	if clear: print("\033[H\033[J%s" % s)
	else: print(s)
	return(s)

def ask(q):
	"""Asks for confirmation. Aborts otherwise.

	Args:
		q (string): question.
	"""

	answer = ''
	while not answer.lower() in ['y', 'n']:
		print("%s %s" % (q, "(y/n)"))
		answer = sys.stdin.readline().strip()

		if 'n' == answer.lower():
			sys.exit("Aborted.\n")
		elif not 'y' == answer.lower():
			print("Please, answer 'y' or 'n'.\n")

# RUN ==========================================================================

print_settings(args)
ask("Confirm settings and proceed?")

# (1) Identify & sort chromosomes
# (2) Generate bins
# (3) Group cutsites (intersect)
# (4) Normalize over last condition.
# (5) Prepare domain
# (6) Assign reads to bins (intersect)
# (7) Calculate bin statistics
# (8) Combine condition into a single table
# (9) Estimate centrality
# (10) Rank bins
# (11) Write output

# End --------------------------------------------------------------------------

################################################################################
